<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TradingView & Indicators</title>
  <style>
    body { background-color: #111; color: #fff; font-family: Arial, sans-serif; }
    iframe { width: 100%; height: 500px; border: none; }
    .indicator-board { display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0; }
    .indicator { background: #222; padding: 10px; border-radius: 5px; }
    .timeframe button { margin-right: 5px; padding: 5px 10px; }
    .timeframe .active { background: #00aaff; color: #fff; }
  </style>
</head>
<body>
  <h1>TradingView + Indicator Board</h1>
  <div class="timeframe">
    <button onclick="setTimeframe('1w')" class="active">1W</button>
    <button onclick="setTimeframe('1d')">1D</button>
    <button onclick="setTimeframe('4h')">4H</button>
  </div>
  <iframe id="tvChart"></iframe>
  <div class="indicator-board" id="indicatorBoard"></div>

  <script>
    let asset = 'BTCUSDT';
    let timeframe = '1w';
    let indicatorValues = {};
    let price = 0;

    function updateTradingView() {
      const tvURL = `https://s.tradingview.com/widgetembed/?symbol=BINANCE:${asset}&interval=${timeframe.toUpperCase()}&theme=dark&style=1&studies=["IchimokuCloud","MACD4C","RodizRSIEMA","Stochastic","TrendSupportBand","VPVR"]`;
      document.getElementById('tvChart').src = tvURL;
    }

    async function fetchPrice() {
      const res = await fetch(`https://fapi.binance.com/fapi/v1/ticker/price?symbol=${asset}`);
      const data = await res.json();
      price = parseFloat(data.price);
    }

    async function fetchCandleData(symbol, interval = '1w', limit = 100) {
      const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
      const data = await response.json();
      return data.map(candle => parseFloat(candle[4])); // Close prices
    }

    function calculateRSI(closes, period = 14) {
      let gains = 0, losses = 0;
      for (let i = 1; i <= period; i++) {
        const diff = closes[i] - closes[i - 1];
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / period;
      let avgLoss = losses / period;
      for (let i = period + 1; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        avgGain = (avgGain * (period - 1) + (diff > 0 ? diff : 0)) / period;
        avgLoss = (avgLoss * (period - 1) + (diff < 0 ? -diff : 0)) / period;
      }
      const rs = avgGain / avgLoss;
      return 100 - 100 / (1 + rs);
    }

    function calculateMACD(closes, shortPeriod = 12, longPeriod = 26) {
      const ema = (data, period) => {
        const k = 2 / (period + 1);
        return data.reduce((acc, val, i) => {
          if (i === 0) acc.push(val);
          else acc.push(val * k + acc[i - 1] * (1 - k));
          return acc;
        }, []);
      };
      const shortEMA = ema(closes, shortPeriod);
      const longEMA = ema(closes, longPeriod);
      return shortEMA.at(-1) - longEMA.at(-1);
    }

    function calculateStochastic(closes, period = 14) {
      const recent = closes.slice(-period);
      const high = Math.max(...recent);
      const low = Math.min(...recent);
      return ((closes.at(-1) - low) / (high - low)) * 100;
    }

    async function calculateIndicators() {
      await fetchPrice();
      const closes = await fetchCandleData(asset, timeframe, 100);

      indicatorValues.rsi = calculateRSI(closes).toFixed(2);
      indicatorValues.macd = calculateMACD(closes).toFixed(2);
      indicatorValues.stochastic = calculateStochastic(closes).toFixed(2);

      const avgPrice = closes.slice(-20).reduce((a, b) => a + b, 0) / 20;
      indicatorValues.vwap = price > avgPrice ? 'above' : 'below';

      const tenkan = (Math.max(...closes.slice(-9)) + Math.min(...closes.slice(-9))) / 2;
      const kijun = (Math.max(...closes.slice(-26)) + Math.min(...closes.slice(-26))) / 2;
      indicatorValues.ichimoku = price > tenkan && tenkan > kijun ? 'bullish' :
                                price < tenkan && tenkan < kijun ? 'bearish' : 'neutral';

      const priceVolatility = Math.abs(price - avgPrice) / avgPrice;
      indicatorValues.vpvr = priceVolatility > 0.02 ? 'high_volume_node' : 'low_volume_node';

      updateIndicatorDisplay();
    }

    function updateIndicatorDisplay() {
      const board = document.getElementById('indicatorBoard');
      board.innerHTML = '';
      for (const [key, value] of Object.entries(indicatorValues)) {
        const div = document.createElement('div');
        div.className = 'indicator';
        div.innerText = `${key.toUpperCase()}: ${value}`;
        board.appendChild(div);
      }
    }

    function setTimeframe(tf) {
      timeframe = tf;
      document.querySelectorAll('.timeframe button').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      updateTradingView();
      calculateIndicators();
    }

    updateTradingView();
    calculateIndicators();
    setInterval(calculateIndicators, 60000);
  </script>
</body>
</html>
